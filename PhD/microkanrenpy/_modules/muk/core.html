<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>muk.core &#8212; microkanrenpy 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for muk.core</h1><div class="highlight"><pre>
<span></span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Laws</span>
<span class="sd">    ====</span>

<span class="sd">    *law of fresh*</span>
<span class="sd">        if x is fresh, then unify(v, x) succeeds and associates x with v    </span>

<span class="sd">    *law of unify*</span>
<span class="sd">        unify(v, w) is the same as unify(w, v)</span>

<span class="sd">    *law of conde*</span>
<span class="sd">        to get more values from conde, pretend that the successful conde line</span>
<span class="sd">        has failed, refreshing all variables that got an association from that</span>
<span class="sd">        line</span>

<span class="sd">    Commandments</span>
<span class="sd">    ============</span>

<span class="sd">    *second*</span>
<span class="sd">        to transform a function whose value is not a Boolean into a function</span>
<span class="sd">        whose value is a goal, add an extra argument to hold its value, replace</span>
<span class="sd">        `cond` with `conde`, and unnest each question and answer. </span>

<span class="sd">    &gt;&gt;&gt; from muk.core import *</span>
<span class="sd">    &gt;&gt;&gt; from muk.ext import *</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">count</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">reduce</span><span class="p">,</span> <span class="n">wraps</span>

<span class="kn">from</span> <span class="nn">muk.sexp</span> <span class="k">import</span> <span class="o">*</span>


<span class="c1"># STATES {{{</span>

<span class="n">state</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;state&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;sub&#39;</span><span class="p">,</span> <span class="s1">&#39;next_index&#39;</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">emptystate</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">state</span><span class="p">(</span><span class="n">sub</span><span class="o">=</span><span class="p">{},</span> <span class="n">next_index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">states_stream</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">emptystate</span><span class="p">()):</span>
    <span class="n">α</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">α</span>

<span class="c1"># }}}</span>

<span class="c1"># VARS {{{</span>


<span class="k">class</span> <span class="nc">var</span><span class="p">:</span>

    <span class="n">_subscripts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span><span class="s1">&#39;₀&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span><span class="s1">&#39;₁&#39;</span><span class="p">,</span><span class="s1">&#39;2&#39;</span><span class="p">:</span><span class="s1">&#39;₂&#39;</span><span class="p">,</span><span class="s1">&#39;3&#39;</span><span class="p">:</span><span class="s1">&#39;₃&#39;</span><span class="p">,</span><span class="s1">&#39;4&#39;</span><span class="p">:</span><span class="s1">&#39;₄&#39;</span><span class="p">,</span><span class="s1">&#39;5&#39;</span><span class="p">:</span><span class="s1">&#39;₅&#39;</span><span class="p">,</span><span class="s1">&#39;6&#39;</span><span class="p">:</span><span class="s1">&#39;₆&#39;</span><span class="p">,</span><span class="s1">&#39;7&#39;</span><span class="p">:</span><span class="s1">&#39;₇&#39;</span><span class="p">,</span><span class="s1">&#39;8&#39;</span><span class="p">:</span><span class="s1">&#39;₈&#39;</span><span class="p">,</span><span class="s1">&#39;9&#39;</span><span class="p">:</span><span class="s1">&#39;₉&#39;</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">__eq__var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__eq__var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">index</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subscripts</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> 
            <span class="c1"># according to *chicken scheme*, function `append` is defined only</span>
            <span class="c1"># on proper lists, unless the very last one which is allowed to be</span>
            <span class="c1"># an improper list. Therefore, we discard the case of `other` to be</span>
            <span class="c1"># a `tuple`, which means `other` is an improper list, so we append</span>
            <span class="c1"># `self` to the end and, finally, make the entire obj a `tuple`</span>
            <span class="c1"># because `self` is a logic variable that can be unified with *any*</span>
            <span class="c1"># value, not just [] to be proper lists.</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">other</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">])</span>
        <span class="c1">#if isinstance(other, str): </span>
            <span class="c1">#return tuple(list(other) + [self])</span>

        <span class="k">raise</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">walk_star</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">W</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">reify_s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ext_s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rvar</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)),</span> <span class="n">sub</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">ext_s</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span> 
        <span class="k">try</span><span class="p">:</span>
            <span class="n">UV</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_unification_var</span> <span class="c1"># attribute lookup to do double dispatch</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ext_s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">ext_s</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_unification_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_var</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">ext_s</span><span class="p">,</span> <span class="n">U</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sub</span> <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other_var</span> <span class="k">else</span> <span class="n">ext_s</span><span class="p">(</span><span class="n">other_var</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_unification_&#39;</span><span class="p">):</span> 
            <span class="k">raise</span> <span class="ne">AttributeError</span>

        <span class="k">return</span> <span class="k">lambda</span> <span class="n">other</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">ext_s</span><span class="p">,</span> <span class="n">U</span><span class="p">:</span> <span class="n">ext_s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">occur_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">O</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">u</span><span class="p">:</span> <span class="k">raise</span> <span class="n">E</span>


<span class="k">class</span> <span class="nc">rvar</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">reifed_name</span><span class="o">=</span><span class="s1">&#39;▢&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">reifed_name</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">reify_s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sub</span>

<span class="c1"># }}}</span>

<span class="c1"># UNIFICATION {{{</span>

<span class="k">class</span> <span class="nc">Tautology</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tautology</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>

<span class="k">class</span> <span class="nc">UnificationError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="k">pass</span>

<div class="viewcode-block" id="unification"><a class="viewcode-back" href="../../under_the_hood.html#muk.core.unification">[docs]</a><span class="k">def</span> <span class="nf">unification</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">ext_s</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Attempts to augment substitution ``sub`` with associations that makes ``u``</span>
<span class="sd">    unify with ``v``.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">sub</span><span class="p">),</span> <span class="n">walk</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="s1">&#39;unification&#39;</span><span class="p">):</span> 
        <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">unification</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">ext_s</span><span class="p">,</span> <span class="n">unification</span><span class="p">,</span> <span class="n">UnificationError</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnificationError</span><span class="p">:</span> <span class="k">pass</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;unification&#39;</span><span class="p">):</span> 
        <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">unification</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">ext_s</span><span class="p">,</span> <span class="n">unification</span><span class="p">,</span> <span class="n">UnificationError</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnificationError</span><span class="p">:</span> <span class="k">pass</span>

    <span class="k">if</span>  <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> \
        <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># this branch permits either `u` or `v` to be `cons` cells too:</span>
        <span class="c1"># can be source of trouble or should be a kind of generalization</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="nb">iter</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">subr</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">subr</span><span class="p">,</span> <span class="n">pair</span><span class="p">:</span> <span class="n">unification</span><span class="p">(</span><span class="o">*</span><span class="n">pair</span><span class="p">,</span> <span class="n">subr</span><span class="p">,</span> <span class="n">ext_s</span><span class="p">),</span> <span class="nb">zip</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">sub</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="c1"># because both iterables are empty, so there&#39;s no</span>
                <span class="c1"># counterexample against their unification</span>
                <span class="k">return</span> <span class="n">subr</span> 
    <span class="k">elif</span> <span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sub</span>

    <span class="k">raise</span> <span class="n">UnificationError</span><span class="p">()</span></div>

<span class="c1"># }}}</span>

<span class="c1"># SUBSTITUTION {{{</span>

<span class="k">def</span> <span class="nf">walk</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">sub</span><span class="p">):</span>

    <span class="k">try</span><span class="p">:</span> 
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span> <span class="n">u</span> <span class="o">=</span> <span class="n">sub</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="c1"># to defend against unhashable objs </span>
            <span class="ne">KeyError</span><span class="p">):</span> <span class="c1"># to defend from &quot;ground&quot; objs and stop iter when `u` is a *fresh* var</span>
        <span class="k">return</span> <span class="n">u</span> 

<span class="k">def</span> <span class="nf">walk_star</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sub</span><span class="p">):</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="k">return</span> <span class="p">[</span><span class="n">walk_star</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]</span>  
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;walk_star&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">walk_star</span><span class="p">(</span><span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="n">walk_star</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">sub</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">v</span>

<span class="k">class</span> <span class="nc">OccurCheck</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">occur_check</span><span class="p">(</span><span class="n">ext_s</span><span class="p">):</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">ext_s</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">E_s</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">occur_check</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        
        <span class="k">def</span> <span class="nf">O</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;occur_check&#39;</span><span class="p">):</span> 
                <span class="n">v</span><span class="o">.</span><span class="n">occur_check</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">O</span><span class="p">,</span> <span class="n">OccurCheck</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> 
                <span class="k">for</span> <span class="n">vv</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span> <span class="n">O</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">vv</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">occur_check</span><span class="p">:</span> <span class="n">O</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ext_s</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">E_s</span>

<span class="nd">@occur_check</span>
<span class="k">def</span> <span class="nf">ext_s</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">sub</span><span class="p">):</span>

    <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span> 
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non `var` obj </span><span class="si">{}</span><span class="s2"> as key in substitution </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">sub</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Illegal identity association between </span><span class="si">{}</span><span class="s1"> and </span><span class="si">{}</span><span class="s1">, according to 9.12 of The Reasoned Schemer&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            
    <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">sub</span><span class="p">:</span> <span class="c1"># check to ensure consistency of previously unified values</span>
        <span class="k">if</span> <span class="n">sub</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span> <span class="k">raise</span> <span class="n">UnificationError</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">sub</span>

    <span class="n">e</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">e</span>

<span class="k">def</span> <span class="nf">reify_s</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sub</span><span class="p">):</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;reify_s&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">reify_s</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">reify_s</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">sub</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">reify_s</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">sub</span><span class="p">),</span> <span class="n">v</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">sub</span>

<span class="k">def</span> <span class="nf">reify</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">walk_star</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">reify_s</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="p">{}))</span>

<span class="c1"># }}}</span>

<span class="c1"># GOAL CTORS {{{</span>

<div class="viewcode-block" id="succeed"><a class="viewcode-back" href="../../under_the_hood.html#muk.core.succeed">[docs]</a><span class="k">def</span> <span class="nf">succeed</span><span class="p">(</span><span class="n">s</span> <span class="p">:</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; A goal that is satisfied by *any* substitution.&#39;&#39;&#39;</span>
    <span class="k">yield from</span> <span class="nb">iter</span><span class="p">([</span><span class="n">s</span><span class="p">])</span></div>

<div class="viewcode-block" id="fail"><a class="viewcode-back" href="../../under_the_hood.html#muk.core.fail">[docs]</a><span class="k">def</span> <span class="nf">fail</span><span class="p">(</span><span class="n">s</span> <span class="p">:</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; A goal that is satisfied by *no* substitution.&#39;&#39;&#39;</span>
    <span class="k">yield from</span> <span class="nb">iter</span><span class="p">([])</span></div>

<div class="viewcode-block" id="_unify"><a class="viewcode-back" href="../../under_the_hood.html#muk.core._unify">[docs]</a><span class="k">def</span> <span class="nf">_unify</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ext_s</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Attempts to perform :py:func:`unification &lt;muk.core.unification&gt;` to make</span>
<span class="sd">    ``u`` and ``v`` unifiable given a set of associations for logic variables.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">U</span><span class="p">(</span><span class="n">s</span> <span class="p">:</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">unification</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="n">ext_s</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnificationError</span><span class="p">:</span> <span class="k">yield from</span> <span class="n">fail</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">yield from</span> <span class="n">succeed</span><span class="p">(</span><span class="n">state</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">next_index</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">U</span></div>

<span class="k">def</span> <span class="nf">_unify_pure</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">occur_check</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_unify</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">ext_s</span><span class="p">,</span> <span class="n">occur_check</span><span class="o">=</span><span class="n">occur_check</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_unify_occur_check</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>

    <span class="n">U</span> <span class="o">=</span> <span class="n">_unify_pure</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">occur_check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">U_oc</span><span class="p">(</span><span class="n">s</span> <span class="p">:</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">U</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">OccurCheck</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">fail</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">U_oc</span>

<div class="viewcode-block" id="fresh"><a class="viewcode-back" href="../../under_the_hood.html#muk.core.fresh">[docs]</a><span class="k">def</span> <span class="nf">fresh</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">arity</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Introduce new logic variables according to the needs of receiver ``f``.</span>

<span class="sd">    If ``f`` is a thunk then ``fresh`` is equivalent to the inversion of η-rule </span>
<span class="sd">    as defined in *higher-order* logic::</span>

<span class="sd">        def η_inverse(t):</span>

<span class="sd">            def I(s : state):</span>
<span class="sd">                g = t()</span>
<span class="sd">                yield from g(s)</span>

<span class="sd">            return I</span>

<span class="sd">    having particular application in the definition of *recursive* relations.</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">arity</span><span class="p">:</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arity</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">)]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f_sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">arity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f_sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span> 

    <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">s</span> <span class="p">:</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">logic_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">next_index</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;logic_vars&#39;</span><span class="p">,</span> <span class="n">logic_vars</span><span class="p">)</span> <span class="c1"># set the attr in any case, even if `logic_vars == []` because of η-inversion  </span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">logic_vars</span><span class="p">)</span>
        <span class="n">α</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">state</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">next_index</span> <span class="o">+</span> <span class="n">arity</span><span class="p">))</span>
        <span class="k">yield from</span> <span class="n">α</span>

    <span class="k">return</span> <span class="n">F</span></div>

<div class="viewcode-block" id="_disj"><a class="viewcode-back" href="../../under_the_hood.html#muk.core._disj">[docs]</a><span class="k">def</span> <span class="nf">_disj</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">interleaving</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A goal that is satisfiable if *either* goal ``g1`` *or* goal ``g2`` is satisfiable.</span>

<span class="sd">    Formally, it produces the following states space:</span>

<span class="sd">    .. math::</span>

<span class="sd">         \left( \\begin{array}{c}s \stackrel{g_{1}}{\\mapsto} \\alpha \\\\ s \stackrel{g_{2}}{\\mapsto} \\beta \\end{array}\\right)</span>
<span class="sd">          = \left( \\begin{array}{ccccc}        </span>
<span class="sd">                s_{00} &amp; s_{01} &amp; s_{02} &amp; s_{03} &amp; \\ldots \\\\</span>
<span class="sd">                s_{10} &amp; s_{11} &amp; s_{12} &amp; s_{13} &amp; \\ldots \\\\</span>
<span class="sd">                \\end{array}\\right)</span>

<span class="sd">    enumerated using ``mplus`` according to ``interleaving`` arg.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">def</span> <span class="nf">D</span><span class="p">(</span><span class="n">s</span> <span class="p">:</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">α</span><span class="p">,</span> <span class="n">β</span> <span class="o">=</span> <span class="n">g1</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">g2</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="n">mplus</span><span class="p">(</span><span class="nb">iter</span><span class="p">([</span><span class="n">α</span><span class="p">,</span> <span class="n">β</span><span class="p">]),</span> <span class="n">interleaving</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">D</span></div>

<div class="viewcode-block" id="_conj"><a class="viewcode-back" href="../../under_the_hood.html#muk.core._conj">[docs]</a><span class="k">def</span> <span class="nf">_conj</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">interleaving</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A goal that is satisfiable if *both* goal ``g1`` *and* goal ``g2`` is satisfiable.</span>

<span class="sd">    Formally, it produces the following states space:</span>

<span class="sd">    .. math::</span>

<span class="sd">        s \stackrel{g_{1}}{\\mapsto} \\alpha = \left( \\begin{array}{c}s_{0}\\\\s_{1}\\\\s_{2}\\\\ s_{3}\\\\ \\ldots\\end{array}\\right)</span>
<span class="sd">          \stackrel{bind(\\alpha, g_{2})}{\\mapsto} \left( \\begin{array}{ccccc}        </span>
<span class="sd">                                                s_{00} &amp; s_{01} &amp; s_{02} &amp; s_{03} &amp; \\ldots \\\\</span>
<span class="sd">                                                s_{10} &amp; s_{11} &amp; s_{12} &amp; \\ldots &amp;        \\\\</span>
<span class="sd">                                                s_{20} &amp; s_{21} &amp; \\ldots &amp;        &amp;         \\\\</span>
<span class="sd">                                                s_{30} &amp; \\ldots &amp;        &amp;        &amp;         \\\\</span>
<span class="sd">                                                \\ldots &amp;        &amp;        &amp;        &amp;         \\\\</span>
<span class="sd">                                                \\end{array}\\right)</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="n">s</span> <span class="p">:</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">α</span> <span class="o">=</span> <span class="n">g1</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="n">bind</span><span class="p">(</span><span class="n">α</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">mplus</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">mplus</span><span class="p">,</span> <span class="n">interleaving</span><span class="o">=</span><span class="n">interleaving</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">C</span></div>

<span class="k">def</span> <span class="nf">if_pure</span><span class="p">(</span><span class="n">question</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">otherwise</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">interleaving</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">s</span> <span class="p">:</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">_conj</span><span class="p">(</span><span class="n">question</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">interleaving</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> 
        <span class="n">α</span><span class="p">,</span> <span class="n">β</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">otherwise</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="n">mplus</span><span class="p">(</span><span class="nb">iter</span><span class="p">([</span><span class="n">α</span><span class="p">,</span> <span class="n">β</span><span class="p">]),</span> <span class="n">interleaving</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">I</span>

<span class="n">ife</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">if_pure</span><span class="p">,</span> <span class="n">interleaving</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ifi</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">if_pure</span><span class="p">,</span> <span class="n">interleaving</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">if_softcut</span><span class="p">(</span><span class="n">question</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">otherwise</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">doer</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">s</span> <span class="p">:</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">α</span> <span class="o">=</span> <span class="n">question</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> 
        <span class="k">try</span><span class="p">:</span>
            <span class="n">r</span> <span class="p">:</span> <span class="n">state</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">α</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span> 
            <span class="n">β</span> <span class="o">=</span> <span class="n">otherwise</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> 
            <span class="k">yield from</span> <span class="n">β</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">γ</span> <span class="o">=</span> <span class="n">doer</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">α</span><span class="p">,</span> <span class="n">answer</span><span class="p">)</span>
            <span class="k">yield from</span> <span class="n">γ</span>

    <span class="k">return</span> <span class="n">I</span>

<span class="n">ifa</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">if_softcut</span><span class="p">,</span> <span class="n">doer</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">α</span><span class="p">,</span> <span class="n">answer</span><span class="p">:</span> 
        <span class="n">bind</span><span class="p">(</span><span class="n">chain</span><span class="p">([</span><span class="n">r</span><span class="p">],</span> <span class="n">α</span><span class="p">),</span> <span class="n">answer</span><span class="p">,</span> <span class="n">mplus</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">mplus</span><span class="p">,</span> <span class="n">interleaving</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>
<span class="n">ifu</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">if_softcut</span><span class="p">,</span> <span class="n">doer</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">α</span><span class="p">,</span> <span class="n">answer</span><span class="p">:</span> <span class="n">answer</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">delimited</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>

    <span class="n">available</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">if</span> <span class="n">d</span> <span class="k">else</span> <span class="n">count</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">one_more</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">available</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">D</span><span class="p">(</span><span class="n">g</span><span class="p">):</span> 
        <span class="k">def</span> <span class="nf">G</span><span class="p">(</span><span class="n">s</span> <span class="p">:</span> <span class="n">state</span><span class="p">):</span>
            <span class="n">α</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">one_more</span><span class="p">()</span> <span class="k">else</span> <span class="n">fail</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">yield from</span> <span class="n">α</span>
                
        <span class="k">return</span> <span class="n">G</span>

    <span class="k">yield</span> <span class="n">D</span>

<span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="o">*</span><span class="n">logic_vars</span><span class="p">,</span> <span class="n">into</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">P</span><span class="p">(</span><span class="n">s</span> <span class="p">:</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">walked_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">walk_star</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">sub</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">logic_vars</span><span class="p">]</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">into</span><span class="p">(</span><span class="o">*</span><span class="n">walked_vars</span><span class="p">)</span>
        <span class="n">α</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> 
        <span class="k">yield from</span> <span class="n">α</span>

    <span class="k">return</span> <span class="n">P</span>

<span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="o">*</span><span class="n">logic_vars</span><span class="p">,</span> <span class="n">of</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">λ</span><span class="p">(</span><span class="n">s</span> <span class="p">:</span> <span class="n">state</span><span class="p">):</span>  
        <span class="n">lvars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">logic_vars</span><span class="p">)</span> <span class="k">if</span> <span class="n">logic_vars</span> <span class="k">else</span> <span class="n">s</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">state</span><span class="p">({</span><span class="n">v</span><span class="p">:{</span><span class="n">v</span><span class="p">:</span><span class="n">s</span><span class="o">.</span><span class="n">sub</span><span class="p">[</span><span class="n">v</span><span class="p">]}</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">lvars</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">sub</span><span class="p">},</span> <span class="n">s</span><span class="o">.</span><span class="n">next_index</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">S</span><span class="p">(</span><span class="n">s</span> <span class="p">:</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">α</span> <span class="o">=</span> <span class="n">of</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> 
        <span class="k">yield from</span> <span class="nb">map</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="n">α</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">S</span>

<span class="k">def</span> <span class="nf">complement</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="n">s</span> <span class="p">:</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">α</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">r</span> <span class="p">:</span> <span class="n">state</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">α</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">succeed</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">fail</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>    

    <span class="k">return</span> <span class="n">C</span>

<span class="c1"># }}}</span>

<span class="c1"># STATE STREAMS {{{</span>

<div class="viewcode-block" id="mplus"><a class="viewcode-back" href="../../under_the_hood.html#muk.core.mplus">[docs]</a><span class="k">def</span> <span class="nf">mplus</span><span class="p">(</span><span class="n">streams</span><span class="p">,</span> <span class="n">interleaving</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    It enumerates the states space ``streams``, using different strategies</span>
<span class="sd">    according to ``interleaving``.</span>

<span class="sd">    In order to understand states enumeration can be helpful to use a matrix,</span>
<span class="sd">    where we associate a row to each stream of states α belonging to</span>
<span class="sd">    ``streams``.  Since ``streams`` is an ``iter`` obj over a *countably*,</span>
<span class="sd">    possibly infinite, set of *states streams*, the matrix could have infinite</span>
<span class="sd">    rows.  In parallel, since each states stream α lying on a row is a ``iter``</span>
<span class="sd">    obj over a *countably*, possibly infinite, set of *satisfying states*, the</span>
<span class="sd">    matrix could have infinite columns; therefore, the matrix we are building</span>
<span class="sd">    could be infinite in both dimensions. So, let ``streams`` be represented as follows:</span>


<span class="sd">    .. math::</span>

<span class="sd">        \left( \\begin{array}{ccccc}        </span>
<span class="sd">        s_{00} &amp; s_{01} &amp; s_{02} &amp; s_{03} &amp; \\ldots \\\\</span>
<span class="sd">        s_{10} &amp; s_{11} &amp; s_{12} &amp; \\ldots &amp;        \\\\</span>
<span class="sd">        s_{20} &amp; s_{21} &amp; \\ldots &amp;        &amp;         \\\\</span>
<span class="sd">        s_{30} &amp; \\ldots &amp;        &amp;        &amp;         \\\\</span>
<span class="sd">        \\ldots &amp;        &amp;        &amp;        &amp;         \\\\</span>
<span class="sd">        \\end{array}\\right)</span>

<span class="sd">    In order to enumerate this infinite matrix we have the following strategies:</span>

<span class="sd">    *depth-first*</span>
<span class="sd">        Enumerates a stream α committed to it until it is saturated or continue to yield its</span>
<span class="sd">        ``state`` objects forever; in other words, it enumerates row by row. For the sake of clarity,</span>
<span class="sd">        assume the first :math:`k` streams are finite and the :math:`k`-th is the first to be infinite, hence</span>
<span class="sd">        we are in the following context:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \left( \\begin{array}{ccccc}        </span>
<span class="sd">            s_{00} &amp; s_{01} &amp; \\ldots &amp; s_{0i_{0}} \\\\</span>
<span class="sd">            s_{10} &amp; s_{11} &amp; \\ldots &amp; s_{1i_{1}} \\\\</span>
<span class="sd">            \ldots_{\\triangle} \\\\</span>
<span class="sd">            s_{k-1, 0} &amp; s_{k-1,1} &amp; \\ldots &amp;  s_{k-1,i_{k-1}} \\\\</span>
<span class="sd">            s_{k0} &amp; s_{k1} &amp; \\ldots &amp;  \ldots &amp;  \ldots \\\\</span>
<span class="sd">            s_{k+1, 0} &amp; \\ldots &amp;        &amp;   \\\\</span>
<span class="sd">            \\ldots &amp;        &amp;        &amp;   \\\\</span>
<span class="sd">            \\end{array}\\right)</span>

<span class="sd">        so enumeration proceeds as follows: :math:`s_{00}, s_{01},\\ldots,</span>
<span class="sd">        s_{0i_{0}}, s_{10}, s_{11}, \\ldots, s_{1i_{1}}, \\ldots_{\\triangle}, s_{k-1,0},</span>
<span class="sd">        s_{k-1, 1},\\ldots, s_{k-1,i_{k-1}}, s_{k0}, s_{k1},\\ldots` yielding from stream :math:`\\alpha_{k}` forever,</span>
<span class="sd">        *never* reaching :math:`s_{k+1, 0}`.</span>

<span class="sd">    *breadth-first*</span>
<span class="sd">        Enumerates interleaving *state* objects belonging to adjacent streams,</span>
<span class="sd">        lying on the same column; in other words, it enumerates column by</span>
<span class="sd">        column. If ``streams`` is an iterator over an infinite set of streams,</span>
<span class="sd">        the it enumerates only the very first ``state`` objects, namely</span>
<span class="sd">        :math:`s_{00}, s_{10}, s_{20}, s_{30},\ldots`. </span>
<span class="sd">        </span>
<span class="sd">        The following is a straighforward implementation::</span>

<span class="sd">            from itertools import chain</span>

<span class="sd">            while True:</span>
<span class="sd">                try: </span>
<span class="sd">                    α = next(streams)</span>
<span class="sd">                except StopIteration: </span>
<span class="sd">                    break</span>
<span class="sd">                else:</span>
<span class="sd">                    try:</span>
<span class="sd">                        s : state = next(α)</span>
<span class="sd">                    except StopIteration:</span>
<span class="sd">                        continue</span>
<span class="sd">                    else:</span>
<span class="sd">                        yield s</span>
<span class="sd">                        streams = chain(streams, [α])</span>

<span class="sd">    *dovetail*</span>
<span class="sd">        Enumerates interleaving `state` objects lying on the same *diagonal*,</span>
<span class="sd">        resulting in a *fair scheduler* in the sense that *every* satisfying</span>
<span class="sd">        ``state`` object will be reached, eventually. For the sake of clarity,</span>
<span class="sd">        enumeration proceeds as follows: </span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>

<span class="sd">            s_{00}, s_{10}, s_{01}, s_{20}, s_{11}, s_{02}, s_{30}, s_{21},</span>
<span class="sd">            s_{12}, s_{03}, \\ldots</span>

<span class="sd">        providing a *complete* enumeration strategy.</span>


<span class="sd">    :param iter stream: an iterator over a *countable* set of ``state``-streams</span>
<span class="sd">    :param bool interleaving: enumeration strategy selector: *dovetail* if ``interleaving`` else *depth-first*</span>
<span class="sd">    :return: an ``iter`` object over satisfying ``state`` objects</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">interleaving</span><span class="p">:</span>

        <span class="k">try</span><span class="p">:</span> <span class="n">α</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">streams</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span> <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">S</span> <span class="o">=</span> <span class="p">[</span><span class="n">α</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">S</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">))):</span>
                <span class="n">β</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">β</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span> <span class="k">del</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span> <span class="k">yield</span> <span class="n">s</span>
            
            <span class="k">try</span><span class="p">:</span> <span class="n">α</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">streams</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span> <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">α</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="k">for</span> <span class="n">α</span> <span class="ow">in</span> <span class="n">streams</span><span class="p">:</span> <span class="k">yield from</span> <span class="n">α</span></div>


                

<div class="viewcode-block" id="bind"><a class="viewcode-back" href="../../under_the_hood.html#muk.core.bind">[docs]</a><span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="n">α</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">mplus</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A stream combinator, it applies goal ``g`` to each ``state`` in stream ``α``.</span>

<span class="sd">    Such mapping can be *linear* in the sense of vanilla ``map`` application:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\alpha = \left( \\begin{array}{c}s_{0}\\\\s_{1}\\\\s_{2}\\\\ s_{3}\\\\ \\ldots\\end{array}\\right)</span>
<span class="sd">          \stackrel{map(g, \\alpha)}{\\mapsto} \left( \\begin{array}{ccccc}        </span>
<span class="sd">                                                s_{00} &amp; s_{01} &amp; s_{02} &amp; s_{03} &amp; \\ldots \\\\</span>
<span class="sd">                                                s_{10} &amp; s_{11} &amp; s_{12} &amp; \\ldots &amp;        \\\\</span>
<span class="sd">                                                s_{20} &amp; s_{21} &amp; \\ldots &amp;        &amp;         \\\\</span>
<span class="sd">                                                s_{30} &amp; \\ldots &amp;        &amp;        &amp;         \\\\</span>
<span class="sd">                                                \\ldots &amp;        &amp;        &amp;        &amp;         \\\\</span>
<span class="sd">                                                \\end{array}\\right)</span>

<span class="sd">    After the mapping obj is built, it is consumed as argument by ``mplus`` to</span>
<span class="sd">    enumerate the states space.</span>

<span class="sd">    Moreover, a recursive implementation can be written as found in *The</span>
<span class="sd">    Reasoned Schemer*, but in some cases it raises ``RecursionError`` due to</span>
<span class="sd">    Python limitation on stack usage::</span>

<span class="sd">        try:</span>
<span class="sd">            s : state = next(α)</span>
<span class="sd">        except StopIteration:</span>
<span class="sd">            yield from fail()</span>
<span class="sd">        else:</span>
<span class="sd">            β = g(s)</span>
<span class="sd">            γ = bind(α, g, mplus)</span>
<span class="sd">            yield from mplus(iter([β, γ]))</span>

<span class="sd">    which produces the following states space:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\alpha = \left( \\begin{array}{c}s_{0}\\\\s_{1}\\\\s_{2}\\\\ s_{3}\\\\ \\ldots\\end{array}\\right)</span>
<span class="sd">          \stackrel{bind(\\alpha, g)}{\\mapsto} \left( \\begin{array}{l}        </span>
<span class="sd">                                                s_{00} \, s_{01} \, s_{02} \, s_{03} \, s_{04} \,s_{05} \,\\ldots \\\\</span>
<span class="sd">                                                \left( \\begin{array}{l}</span>
<span class="sd">                                                s_{10} \, s_{11} \, s_{12} \, \\ldots \,        \\\\</span>
<span class="sd">                                                \left( \\begin{array}{l}        </span>
<span class="sd">                                                s_{20} \, s_{21} \, \\ldots \,        \,         \\\\</span>
<span class="sd">                                                \left( \\begin{array}{l}        </span>
<span class="sd">                                                s_{30} \, \\ldots \,        \,        \,         \\\\</span>
<span class="sd">                                                \\ldots \,        \,        \,        \,         \\\\</span>
<span class="sd">                                                \\end{array}\\right)</span>
<span class="sd">                                            \\end{array}\\right)</span>
<span class="sd">                                        \\end{array}\\right)</span>
<span class="sd">                                    \\end{array}\\right)</span>

<span class="sd">    assuming we want to enumerate using interleaving:</span>

<span class="sd">    .. math::</span>

<span class="sd">        s_{00}, s_{10}, s_{01}, s_{20}, s_{02}, s_{11}, s_{03}, s_{30}, s_{04}, s_{12}, s_{05}, s_{21}\ldots</span>

<span class="sd">    which, although *complete*, is *unbalanced* in favor of first streams.</span>

<span class="sd">    :param iter α: an iterator over a *countable* set of ``state`` objects</span>
<span class="sd">    :param goal g: a relation to be satisfied</span>
<span class="sd">    :param callable mplus: states space enumeration strategy</span>
<span class="sd">    :return: an ``iter`` object over satisfying ``state`` objects</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">yield from</span> <span class="n">mplus</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">α</span><span class="p">))</span></div>

<span class="c1"># }}}</span>

<span class="c1"># INTERFACE {{{</span>

<div class="viewcode-block" id="run"><a class="viewcode-back" href="../../under_the_hood.html#muk.core.run">[docs]</a><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">goal</span><span class="p">,</span> 
        <span class="n">n</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
        <span class="n">var_selector</span><span class="o">=</span><span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">post</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">cons_to_list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">cons</span><span class="p">)</span> <span class="k">else</span> <span class="n">r</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Looks for a list of at most ``n`` associations ``[(u, v) for v in ...]``</span>
<span class="sd">    such that when var ``u`` takes value ``v`` the relation ``goal`` is</span>
<span class="sd">    satisfied, where ``u`` is the *main var* respect the whole ``run``</span>
<span class="sd">    invocation; otherwise, it enumerates the relation if ``n`` is ``False``.</span>

<span class="sd">    :param goal: the relation to be satisfied respect to the main var according to :py:obj:`var_selector`.</span>



<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">with</span> <span class="n">states_stream</span><span class="p">(</span><span class="n">goal</span><span class="p">)</span> <span class="k">as</span> <span class="n">α</span><span class="p">:</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="k">else</span> <span class="n">count</span><span class="p">()</span>
        <span class="n">subs</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">sub</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">α</span><span class="p">)]</span>

    <span class="n">logic_vars</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">goal</span><span class="p">,</span> <span class="s1">&#39;logic_vars&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="c1"># defaults to `None` instead of `[]` to distinguish attr set by `_fresh` </span>
    <span class="n">m_var</span> <span class="o">=</span> <span class="n">var_selector</span><span class="p">(</span><span class="o">*</span><span class="n">logic_vars</span><span class="p">)</span> <span class="k">if</span> <span class="n">logic_vars</span> <span class="k">else</span> <span class="n">Tautology</span><span class="p">()</span> <span class="c1"># any satisfying sub is a Tautology if there are no logic vars</span>

    <span class="k">def</span> <span class="nf">λ</span><span class="p">(</span><span class="n">sub</span><span class="p">):</span> 
        <span class="n">w_var</span> <span class="o">=</span> <span class="n">walk_star</span><span class="p">(</span><span class="n">m_var</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span> <span class="c1"># instantiate every content in the expr associated to `main_var` in `sub` to the most specific value</span>
        <span class="n">r_var</span> <span class="o">=</span> <span class="n">reify</span><span class="p">(</span><span class="n">w_var</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">post</span><span class="p">(</span><span class="n">r_var</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="n">subs</span><span class="p">))</span></div>


<span class="c1"># }}}</span>


</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Massimo Nocentini.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>